import streamlit as st
import math
import random
import matplotlib.pyplot as plt

st.set_page_config(page_title="Recuit SimulÃ© Visualizer", page_icon="ğŸ”¥", layout="centered")

# --- TITRE ---
st.title("ğŸ”¥ Visualisation du Recuit SimulÃ© (Simulated Annealing)")
st.write("""
Cet outil interactif permet de visualiser le **Recuit SimulÃ©**, 
une mÃ©thode d'optimisation inspirÃ©e du refroidissement des mÃ©taux.
Il cherche Ã  minimiser l'Â« Ã©nergie Â» (ici, la distance totale entre les villes).
""")

# --- PARAMÃˆTRES ---
with st.expander("âš™ï¸ ParamÃ¨tres de l'algorithme", expanded=True):
    temp_initiale = st.slider("TempÃ©rature initiale", 100, 5000, 1000, step=100)
    refroid = st.slider("Facteur de refroidissement", 0.80, 0.999, 0.95)
    iterations = st.slider("Nombre d'itÃ©rations", 100, 5000, 1000, step=100)
    nb_villes = st.slider("Nombre de villes", 5, 10, 6)

# --- MATRICE D'Ã‰NERGIE ---
@st.cache_data
def generer_matrice(nb_villes):
    return [[0 if i == j else random.randint(2, 15) for j in range(nb_villes)] for i in range(nb_villes)]

matrice_energies = generer_matrice(nb_villes)

# --- FONCTIONS DU RECUIT ---
def calcul_energie(etat, matrice_energie):
    energie_totale = 0
    for i in range(len(etat) - 1):
        energie_totale += matrice_energie[etat[i]][etat[i + 1]]
    energie_totale += matrice_energie[etat[-1]][etat[0]]
    return energie_totale

def generer_voisin(etat):
    voisin = etat[:]
    i, j = random.sample(range(len(etat)), 2)
    voisin[i], voisin[j] = voisin[j], voisin[i]
    return voisin

def recuit_simule(matrice_energie, temp_initiale, refroid, iterations):
    nb_villes = len(matrice_energie)
    etat_courant = list(range(nb_villes))
    random.shuffle(etat_courant)
    energie_courante = calcul_energie(etat_courant, matrice_energie)
    meilleur_etat = etat_courant[:]
    meilleure_energie = energie_courante
    temperature = temp_initiale
    historique = [energie_courante]

    for _ in range(iterations):
        nouvel_etat = generer_voisin(etat_courant)
        energie_nouvelle = calcul_energie(nouvel_etat, matrice_energie)
        delta = energie_nouvelle - energie_courante
        if delta < 0 or random.random() < math.exp(-delta / temperature):
            etat_courant = nouvel_etat
            energie_courante = energie_nouvelle
        if energie_courante < meilleure_energie:
            meilleur_etat = etat_courant[:]
            meilleure_energie = energie_courante
        historique.append(meilleure_energie)
        temperature *= refroid
    return meilleur_etat, meilleure_energie, historique

# --- BOUTON D'EXÃ‰CUTION ---
if st.button("ğŸš€ Lancer le recuit simulÃ©"):
    with st.spinner("ExÃ©cution de l'algorithme..."):
        meilleur_etat, meilleure_energie, historique = recuit_simule(
            matrice_energies, temp_initiale, refroid, iterations
        )

    st.success(f"âœ… Ã‰nergie minimale atteinte : **{meilleure_energie}**")
    st.write(f"Chemin final (Ã©tat) : {meilleur_etat}")

    # --- VISUALISATION ---
    plt.figure(figsize=(8, 4))
    plt.plot(historique, label="Ã‰nergie au fil des itÃ©rations")
    plt.title("Ã‰volution de l'Ã©nergie")
    plt.xlabel("ItÃ©ration")
    plt.ylabel("Ã‰nergie")
    plt.legend()
    st.pyplot(plt)

    st.caption("On observe la diminution progressive de l'Ã©nergie au fil des itÃ©rations.")

